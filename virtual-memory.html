<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scarboroughcoral.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.8.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="理论驱动实践，实践驱动理论。">
<meta property="og:type" content="article">
<meta property="og:title" content="通用操作系统原理之虚拟内存">
<meta property="og:url" content="https://scarboroughcoral.github.io/virtual-memory.html">
<meta property="og:site_name" content="李明岳的网络日志">
<meta property="og:description" content="理论驱动实践，实践驱动理论。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/vm-problem1.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/vm-problem2.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/vm-problem3.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/whatis-vm1.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/not-enough-memory.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/memory-hole.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/program-secure.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/memory-share.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/vm-work1.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/vm-work2.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/page-table1.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/page-table2.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/page-table3.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/addr-trans1.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/addr-trans2.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/addr-trans3.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/addr-trans4.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/addr-trans5.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/addr-trans6.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/mem-protection1.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/mem-protection2.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/mem-protection3.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/mem-protection4.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/mem-fast1.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/mem-fast2.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/mem-fast3.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/tlb-example1.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/tlb-example2.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/tlb-example3.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/tlb-example4.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/multi-level-page-table1.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/multi-level-page-table2.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/multi-level-page-table3.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/tlb-cache1.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/tlb-cache2.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/tlb-cache3.png">
<meta property="og:image" content="https://scarboroughcoral.github.io/virtual-memory/tlb-cache4.png">
<meta property="article:published_time" content="2018-12-09T12:51:13.000Z">
<meta property="article:modified_time" content="2021-11-03T12:00:18.789Z">
<meta property="article:author" content="李明岳">
<meta property="article:tag" content="Operating System">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://scarboroughcoral.github.io/virtual-memory/vm-problem1.png">


<link rel="canonical" href="https://scarboroughcoral.github.io/virtual-memory.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://scarboroughcoral.github.io/virtual-memory.html","path":"virtual-memory.html","title":"通用操作系统原理之虚拟内存"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>通用操作系统原理之虚拟内存 | 李明岳的网络日志</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">李明岳的网络日志</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">虚拟内存问题概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E4%B8%AA%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">三个内存相关的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">3.</span> <span class="nav-text">什么是虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">3.1.</span> <span class="nav-text">中间件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E4%B8%89%E4%B8%AA%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.</span> <span class="nav-text">如何解决三个内存问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E5%92%8C%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.3.</span> <span class="nav-text">页表和转换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8"><span class="nav-number">3.3.1.</span> <span class="nav-text">页表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.3.2.</span> <span class="nav-text">地址转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">4.</span> <span class="nav-text">如何实现虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9B%B4%E5%BF%AB%E5%9C%B0%E5%AE%8C%E6%88%90%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.1.</span> <span class="nav-text">如何更快地完成虚拟地址到物理地址的转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%92%8C%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98Cache"><span class="nav-number">5.</span> <span class="nav-text">虚拟内存和高速缓存Cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">7.</span> <span class="nav-text">参考资料</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E4%BD%9C%E5%93%81"><span class="nav-number">7.1.</span> <span class="nav-text">引用作品</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%96%87%E7%8C%AE"><span class="nav-number">7.2.</span> <span class="nav-text">引用文献</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E9%98%85%E4%B9%A6%E7%9B%AE"><span class="nav-number">7.3.</span> <span class="nav-text">参阅书目</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">李明岳</p>
  <div class="site-description" itemprop="description">一个假的全栈工程师</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ScarboroughCoral" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ScarboroughCoral" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://scarboroughcoral.github.io/virtual-memory.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李明岳">
      <meta itemprop="description" content="一个假的全栈工程师">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李明岳的网络日志">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          通用操作系统原理之虚拟内存
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-12-09 12:51:13" itemprop="dateCreated datePublished" datetime="2018-12-09T12:51:13+00:00">2018-12-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-11-03 12:00:18" itemprop="dateModified" datetime="2021-11-03T12:00:18+00:00">2021-11-03</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer-Science/Operating-System/" itemprop="url" rel="index"><span itemprop="name">Operating System</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <div class="note default"><p>理论驱动实践，实践驱动理论。</p>
</div>

<span id="more"></span>

<h3 id="虚拟内存问题概述"><a href="#虚拟内存问题概述" class="headerlink" title="虚拟内存问题概述"></a>虚拟内存问题概述</h3><p>如果你了解过一点虚拟内存的知识，这篇笔记可能会让你更深入的理解。</p>
<ul>
<li>三个内存相关的问题<ul>
<li>没有足够的内存</li>
<li>地址空间碎片化</li>
<li>地址冲突</li>
</ul>
</li>
<li>什么是虚拟内存<ul>
<li>中间件</li>
<li>如何解决三个内存问题</li>
<li>页表和转换</li>
</ul>
</li>
<li>如何实现虚拟内存<ul>
<li>怎么让转换变得更快</li>
</ul>
</li>
<li>虚拟内存和高速缓存Cache</li>
</ul>
<h3 id="三个内存相关的问题"><a href="#三个内存相关的问题" class="headerlink" title="三个内存相关的问题"></a>三个内存相关的问题</h3><ul>
<li>没有足够的内存怎么办</li>
</ul>
<p>MIPS提供给每个应用程序32位的地址空间，每个应用程序可以访问这32个地址空间中的任意一个字节。最早的MIPS架构是32位，最新的版本已经变成64位。也就是说你可以使用2^32bytes也就是4GB，这只是理论上，实际可能会缩小到2GB可用空间。</p>
<p>如果你的物理内存（内存条）是1GB该怎么办呢？就像下面这个图，可寻址空间大于实际物理内存大小。</p>
<p><img data-src="virtual-memory/vm-problem1.png"></p>
<ul>
<li>程序如何分配内存（对于碎片内存）</li>
</ul>
<p>就像下面这张图，首先内存加载程序p1和p2，开始3G空间被占用，剩余1G空间剩余，这时候p1退出，p3想使用内存，虽然还有2G剩余空间，但空间是碎片化的，这也是一个问题。这被称作<strong>Memory fragmentation</strong><code>内存碎片化</code>。</p>
<p><img data-src="virtual-memory/vm-problem2.png"></p>
<ul>
<li>如何保证进程安全（进程之间地址不相互访问）</li>
</ul>
<p>就像下面这张图，两个程序同时访问<code>1024</code>这个地址的空间，内存中的信息会不会相互覆盖？</p>
<p><img data-src="virtual-memory/vm-problem3.png"></p>
<p>总结一下，如果所有程序都有相同的32位的寻址空间，那么可能导致以下问题：</p>
<ul>
<li>如果实际物理能存大小小于4GB电脑可能会崩溃</li>
<li>如果运行多个程序可能会用光所有内存，这不是真正的用光而是碎片化的内存无法真正利用，这种碎片化依赖于我们不同程序的运行次序</li>
<li>不同的进程之间的数据可能会相互覆盖破坏，因为有相同的寻址地址</li>
</ul>
<p>那么如何解决？</p>
<p>问题的关键在于<strong>所有的程序有相同的寻址空间</strong>，那么我们可不可以有属于自己的<strong>虚拟内存</strong>？如果可以的话，我们可以</p>
<ul>
<li>将程序的内存空间和物理内存之间做一个映射（这使得我们使用物理内存RAM变的更加灵活）</li>
<li>当程序用光的时候，我们甚至可以将程序移动到硬盘</li>
</ul>
<h3 id="什么是虚拟内存"><a href="#什么是虚拟内存" class="headerlink" title="什么是虚拟内存"></a>什么是虚拟内存</h3><h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><p>虚拟内存是一层“中间组件”，虚拟内存的想法来自于一句话：</p>
<blockquote>
<p>Any problem in computer science can be solved by adding indirection.<br>任何计算机问题都可以通过添加一个中间件来解决。</p>
</blockquote>
<p>如果没有虚拟内存这一层中间件，程序寻址空间将和实际物理内存相同。例如寻址空间大小大于实际RAM大小，如果你访问地址2024，得到的结果可能和访问地址24相同（因为地址越界最高位失效）。</p>
<p><em>虚拟内存的作用就是将程序地址空间做一层映射映射到实际RAM地址。</em></p>
<p>如下图所示：</p>
<p><img data-src="virtual-memory/whatis-vm1.png"></p>
<h4 id="如何解决三个内存问题"><a href="#如何解决三个内存问题" class="headerlink" title="如何解决三个内存问题"></a>如何解决三个内存问题</h4><ul>
<li>没有足够的内存<br>将一部分程序地址空间映射到硬盘，我们需要他的时候只需要将这一部分加载到内存中即可。内存中的暂时不使用的程序（比如Program0）可以将其放到硬盘中，这个过程叫做<code>Page Out</code>，即内存页换出，并更新映射，然后当新程序（P3）来了就可以映射到内存中原来旧程序（P0）部分。</li>
</ul>
<p><img data-src="virtual-memory/not-enough-memory.png"></p>
<ul>
<li>碎片内存使用</li>
</ul>
<p>这就是前面提到过的问题，如何充分利用程序退出后碎片化的内存？<br>有了前面提及的映射，这个就比较容易解决了，<strong>我们可以将地址空间按照任意方式映射到实际物理内存RAM</strong></p>
<p><img data-src="virtual-memory/memory-hole.png"></p>
<ul>
<li>进程安全（进程之间不相互访问）</li>
</ul>
<p>进程之间的内存如何能够独立、隔离（isolate）出来呢？例如同时访问<code>1024</code>的地址，两个程序如何能保证不是访问的实际物理内存中的同一个区域呢？</p>
<p>通过映射方式我们可以想出来，<strong>只需要保证不同程序的相同虚拟地址映射到不同的物理地址就可以了。</strong></p>
<p><img data-src="virtual-memory/program-secure.png"></p>
<p>这样一来，因为每个程序都有自己的地址空间，那么他们不可能访问其他程序的数据，这非常的安全和可靠！</p>
<p>这也是有缺点的，当两个程序合作的时候，如何共享内存呢？<strong>只需要将两个程序各自的虚拟地址空间拿出一部分映射到相同的物理地址空间</strong>。</p>
<p><img data-src="virtual-memory/memory-share.png"></p>
<h4 id="页表和转换"><a href="#页表和转换" class="headerlink" title="页表和转换"></a>页表和转换</h4><p>前面一直提到的映射就是页表的部分，页表所做的功能就是转换，<code>从VA（Virtual Address）虚拟地址转换为PA（Physical Address）物理地址</code>。页表映射的单位是一个<code>页</code>。</p>
<p>那程序是如何访问内存的呢？</p>
<ul>
<li>CPU执行使用虚拟地址。</li>
<li>MMU将虚拟地址转换成物理地址</li>
<li>（可选）如果转换过程中发现映射表中没有物理内存，那么操作系统就将它从硬盘加载到内存并修改映射表</li>
</ul>
<p><img data-src="virtual-memory/vm-work1.png"></p>
<ul>
<li>通过物理地址读取RAM并将数据返还给程序。</li>
</ul>
<p><img data-src="virtual-memory/vm-work2.png"></p>
<h5 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h5><p>页表保存着VA虚拟地址到PA物理地址的映射方式。</p>
<p>下面一步一步说明页表的构建过程，从有问题的页表到一个臻于完美的页表，这可能是现代计算机操作系统所利用的机制。</p>
<p>既然页表保存着虚拟地址到物理地址的映射，那么页表就需要保存每一个虚拟地址到每一个物理地址的映射，我们称每一条记录为页表入口<code>Page Table Entry (PTE)</code>。如果是这样的话，那需要多大的页表？<strong>结合下图：</strong>如果是32位地址空间，每个字就需要1个PTE，这里一个字是32位，也就是4个字节，所以每4个大小也就是2位的地址空间就需要1个PTE，所以总共需要2^30个PTE。又因为每个PTE存储的是一个映射，由于虚拟地址是连续的可以只用偏移地址来表示，只需要存32位的物理地址，所以总共需要2^30x32b=4GB个大小。这说明1个4GB大小的RAM我们就需要拿出全部容量来存储页表，而且这没有考虑每个程序都需要一个页表。如果你没有明白这个计算公式，你仅需要知道如果这样构造页表所需容量太大，需要改造！</p>
<p><img data-src="virtual-memory/page-table1.png"></p>
<p>那么如何改造呢？以上情况的映射是1个字对应一个PTE页表入口，我们称这种情况为<code>细粒度映射</code>，那我们可不可以使用<code>粗粒度映射</code>呢？就像这个图一样：</p>
<p><img data-src="virtual-memory/page-table2.png"></p>
<p>这个图中，我们将每4Kb大小的地址空间做一个PTE，我们称之为<code>4KB Pages</code>，因为每个RAM按字节计量，或者你可以看为1K个字大小的页。这样我们就减少了映射也就是PTE的个数。这4KB大小的页映射的内部是连续的，如下图：</p>
<p><img data-src="virtual-memory/page-table3.png"></p>
<p>有了以上改进，我们有了更少的PTE映射个数，但是我们页降低了使用RAM的灵活性，因为我们每次需要移动一个页（4KB）。</p>
<p>现代计算机系统中，比较典型的就是4KB Pages（1024 words per page，每一页1024个字）。</p>
<h5 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h5><p>我们需要将虚拟地址转换为物理地址。</p>
<p>假设我们使用的是4KB Pages，我们有32位虚拟地址，28位物理地址，如下图</p>
<p><img data-src="virtual-memory/addr-trans1.png"></p>
<p>那我们4KB大小的页内部没有做映射，这一部分如何映射呢？解决办法就是使用<code>偏移量offset</code>，如下图</p>
<p><img data-src="virtual-memory/addr-trans2.png"></p>
<p>我们将一个虚拟地址转换为物理地址，虚拟地址的pagenumber部分通过页表转换为实际物理地址的pagenumber部分，虚拟地址的offset部分直接作为物理地址的offset部分。</p>
<p><img data-src="virtual-memory/addr-trans3.png"></p>
<p>下面这个例子，32位虚拟地址，28位物理地址，4KB大小的页，所以需要12位offset。当虚拟地址为<strong>0x00003204</strong>的时候，将虚拟地址分为虚拟页编号（<strong>0x00003</strong>）、偏移量（<strong>0x204</strong>），offset直接使用，所以物理页内偏移量为<strong>0x204</strong>，虚拟页编号通过查页表，得到物理页编号为<strong>0x0006</strong>。所以得到的物理地址为<strong>0x0006204</strong></p>
<p><img data-src="virtual-memory/addr-trans4.png"></p>
<p>当然，如果查页表的时候可能会产生<code>page fault</code>，即所需要的内容没有在RAM中，如图中的<strong>0x00000</strong>，这就需要发生中断，加载内容到RAM，然后修改页表，返回到内存上次执行的位置，这时候就会找到所对应的物理页编号了。</p>
<p><img data-src="virtual-memory/addr-trans5.png"></p>
<p>详细说一下当所需要的页不在内存中时会发生什么：</p>
<ul>
<li>页表入口PTE告诉你所需要的页在硬盘中</li>
<li>硬件（CPU）生成一个Page Fault页错误</li>
<li>硬件跳到Page Fault Handler页错误处理程序来处理<ul>
<li>操作系统选择RAM中的一个页剔除写到硬盘中</li>
<li>如果是需要读取的页是脏页，就需要先将其写回到硬盘再读取</li>
<li>操作系统读取所需要的页到RAM</li>
<li>操作系统修改页表的映射</li>
</ul>
</li>
<li>操作系统跳转到发生页错误的地方开始执行（这一次就不会产生页错误了）</li>
</ul>
<blockquote>
<p>脏页是指页中的数据被改变了，如果没有改变，那就没必要写回到硬盘了。</p>
</blockquote>
<blockquote>
<p>脏页－linux内核中的概念，因为硬盘的读写速度远赶不上内存的速度，系统就把读写比较频繁的数据事先放到内存中，以提高读写速度，这就叫高速缓存，linux是以页作为高速缓存的单位，当进程修改了高速缓存里的数据时，该页就被内核标记为脏页，内核将会在合适的时间把脏页的数据写到磁盘中去，以保持高速缓存中的数据和磁盘中的数据是一致的。（来自百度百科）</p>
</blockquote>
<p>那么页不在内存中时，这个过程需要多长时间呢？大约需要80 million 周期，这是采样自现代CPU，其中硬盘的读取占了大多数时间。<em><strong>页错误可能是计算机中最慢的操作了。</strong></em></p>
<p><img data-src="virtual-memory/addr-trans6.png"></p>
<p>既然这么慢，那为什么还要用它呢？</p>
<p>优点：</p>
<ul>
<li>你用光了内存计算机不会发生崩溃<br>缺点：</li>
<li>如果发生页错误会很慢</li>
</ul>
<p>但是现代计算机还是使用内存页机制。如果你有非常大、足够大的RAM就不会发生页置换，这就是我们为什么认为内存越大计算机就变的越快的原因。</p>
<p>足够大的内存这是不可能的，不过一些现代操作系统不会发生页置换：</p>
<ul>
<li>IOS：如果你用了过多的内存，系统会杀死你的进程</li>
<li>OS X 10.9：系统会先压缩你的程序，只有不得不置换的时候才会发生</li>
</ul>
<blockquote>
<p>这可能就是为什么在国内Apple比较受欢迎的原因吧，o(<em>￣︶￣</em>)o</p>
</blockquote>
<p>每个程序都有自己的页表，我们可以把每个程序的虚拟地址映射到独一无二的内存中，这是为了程序之间不会没有预测的访问数据。</p>
<p><img data-src="virtual-memory/mem-protection1.png"></p>
<p>这说明每一个程序都有自己的32位虚拟地址空间，下面是Linux虚拟内存空间的使用情况。</p>
<p><img data-src="virtual-memory/mem-protection2.png"></p>
<p>1GB预留给linux内核作为内核区，栈区可以向下扩展到一个固定的最大值，Libraries区用于一些共享库的放置，堆区用于存储动态申请的内存向上扩展，接下来是data数据区用于存储静态变量，代码区用于放置程序编译之后的<code>二进制代码</code>。这之间有一些随机的偏移，这提高了安全性因为你不知道数据和代码区具体在哪儿。</p>
<p>这是一个具体的例子。</p>
<p><img data-src="virtual-memory/mem-protection3.png"></p>
<p>每个程序都有自己的虚拟地址空间，都有自己的页表映射方式保证了程序之间的隔离，因为不会随意相互访问内存，映射到内存的相同区域保证了程序之间的可合作性。</p>
<p>看一看实际如何使用独立的页表映射方式。这儿有两个程序，CPU都要执行这段指令<code>ld R2,2(R0)</code>，就是将内存地址2的数据加载到R2寄存器中，这里的内存地址是虚拟地址，因此需要通过查页表的方式来查询实际物理内存地址，然后取出数据。因为两个程序有不同的页表，执行指令时取得的虚拟地址2对应的物理地址一般不同或者相同（共享，这只需要将不同地址的虚拟地址映射到相同的RAM物理地址即可），因此最终访问的RAM地址也是不同的。CPU执行上下文切换切换进程时会将进程资源一起切换，这个切换就包含页表的切换。就像下面这张图。</p>
<p><img data-src="virtual-memory/mem-protection4.png"></p>
<h3 id="如何实现虚拟内存"><a href="#如何实现虚拟内存" class="headerlink" title="如何实现虚拟内存"></a>如何实现虚拟内存</h3><p>如何让虚拟内存有作用呢？因为虚拟内存使得内存使用更加灵活，但也有可能降低计算机系统的效率，我们只需要让虚拟内存机制达到尽可能大的效率即可。</p>
<p>虚拟内存的使用过程中需要做什么事情？</p>
<ul>
<li>访问内存中的页表</li>
<li>通过查询页表将虚拟地址转换为物理地址</li>
<li>访问RAM相应物理内存中的数据</li>
</ul>
<p>这个过程中访问了内存2次，访问内存有很多的工作要做，要了解到我们平均每条指令就需要访问1.33次内存（4/3，每三条指令访问4次内存），这部分显得很低效，这是优化的部分之一！</p>
<p>使用虚拟内存有优点，因为有“无限制”的程序和内存（每个程序都有地址空间，内存页可以换入换出），可以保护程序内存实现隔离，使用内存变得很灵活；但使用虚拟内存也会带来很昂贵的资源消耗，每个内存操作都需要查询页表，而且需要访问两次内存（1次页表访问、1次内存物理地址（访问RAM数据）访问）</p>
<h4 id="如何更快地完成虚拟地址到物理地址的转换"><a href="#如何更快地完成虚拟地址到物理地址的转换" class="headerlink" title="如何更快地完成虚拟地址到物理地址的转换"></a>如何更快地完成虚拟地址到物理地址的转换</h4><ul>
<li>TLB<br>因为页表的访问是必须的，所以不可能减少这一部分工作。那我们可不可以通过软件来实现？我们知道这又增加了指令条数，也就增加了内存访问次数。那可不可以通过硬件来实现？添加一个缓存Cache。我们称这个<code>Page Table Cache</code>为<code>Translation Lookaside Buffer(TLB)</code>。他的工作机制如下图</li>
</ul>
<p><img data-src="virtual-memory/mem-fast1.png"></p>
<p>最初，通过访问RAM中的页表来将虚拟地址转换为物理地址，这是非常慢的操作。</p>
<p><img data-src="virtual-memory/mem-fast2.png"></p>
<p>我们通过访问TLB缓存来获取虚拟地址对应的物理地址这是十分迅速的，因为访问速度比RAM快，这非常像一个Cache。如果想让TLB非常迅速，TLB就必须尽可能小。我们通常将TLB分离成指令页缓存（iTLB）和数据页缓存（dTLB），比如现代intel所生产的，每一页4KB，一共有64个页表入口PTE，或者是每一页2MB，32个PTE，都是4路关联（4路组关联，区别于全关联）</p>
<p>全部页表有1M个PTE，但是TLB里只有64个，这个差别很多大，这样访问页的时候如果在TLB里那就会变得很快。</p>
<ul>
<li>页在RAM中<ul>
<li>PTE在TLB<ul>
<li>最快</li>
<li>1个周期用于地址转换，然后访问RAM或cache中的数据</li>
</ul>
</li>
<li>PTE不在TLB<ul>
<li>较慢</li>
<li>20-1000个周期从RAM中加载PTE到TLB，然后访问RAM数据</li>
</ul>
</li>
</ul>
</li>
<li>页不在RAM<ul>
<li>PTE在TLB（几乎不可能，因为最近不经常使用的内存页被置换到硬盘，所以TLB在这段时间内也被置换了）<ul>
<li>很慢</li>
<li>大约80M周期从硬盘加载到内存</li>
</ul>
</li>
<li>PTE不在TLB<ul>
<li>比很慢还慢一点（o(<em>￣︶￣</em>)o）</li>
<li>20-1000个周期地址转换，这时知道内存页在硬盘</li>
<li>大约80M周期从硬盘加载到内存</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>TLB非常的小，怎么让TLB看着大一点，换句话说如何充分利用这么小的一个空间？</p>
<ul>
<li>让每一页变的大一点。例如从64个4KB大小的页（共256KB数据）换为32个2MB大小的页（共64MB数据）</li>
<li>添加一个二级TLB，可能比一级TLB大一点，但是有一点慢。大多数二级TLB是一级TLB大小的八倍，当一级TLB的PTE没有命中的话就去二级TLB去查找加载到一级TLB</li>
</ul>
<p><img data-src="virtual-memory/mem-fast3.png"></p>
<ul>
<li>让硬件自动填充TLB（因为不会经过操作系统的处理）。这被称为<code>Hardware Page Table Walk</code>，由MMU来完成。</li>
</ul>
<p>下面是如何通过TLB将虚拟地址转化为物理地址的例子。</p>
<p><img data-src="virtual-memory/tlb-example1.png"></p>
<p>CPU执行指令的时候，使用到了虚拟内存地址<code>0x00003204</code>，需要将虚拟地址转化为物理地址，首先去TLB查找缓存页表，这个例子中发现TLB中没有所要查找的页表入口PTE，然后就需要通过查找RAM中的页表中的PTE，找到了之后就需要将该PTE加载到TLB，然后将虚拟页编号映射到物理页编号（<code>0x00003-&gt;0x0006</code>），页内偏移直接使用，最终获取物理地址<code>0x0006204</code>。</p>
<p>下面再看一个PTE在TLB中的例子。</p>
<p><img data-src="virtual-memory/tlb-example2.png"></p>
<p>这个例子中CPU中使用虚拟地址<code>0x00003208</code>，首先通过虚拟页编号到TLB中去找，虚拟页编号<code>0x00003</code>，发现该页在TLB中，那就直接转化为物理地址。</p>
<p>下面又是一种情况，当所查找的页不在TLB中且TLB中满时需要做什么，<strong>需要将TLB中选取一个PTE剔除以释放空间</strong></p>
<p><img data-src="virtual-memory/tlb-example3.png"></p>
<p>当所需要的页不在RAM中时会发生什么？CPU使用虚拟地址<code>0x00000860</code>，发现页编号<code>0x0000</code>不在TLB中，然后去RAM页表中查找，发现所需物理页在DISK中，然后就需要将DISK中数据加载到RAM中并更新RAM中的页表，然后将页表中对应的PTE加载到TLB中，将虚拟页号转换为物理页号获取物理地址。</p>
<p><img data-src="virtual-memory/tlb-example4.png"></p>
<ul>
<li>多级页表</li>
</ul>
<p>多级页表是使优化地址转换的另一方法。首先我们考虑一下页表的大小，虽然我们使用了4KB大小的页来减少页表中PTE中的数量，但对于32位大小的虚拟地址空间来说还是会有1M个PTE，每个PTE大约占4B（20位物理地址，还有其他的权限标志位等）。总共4MB。但是我们<strong>每个程序都需要一个页表</strong>，假设我们有<strong>100</strong>个程序在运行，那内存中就需要有400MB来维护各个程序的页表！还有一点，我们无法将页表换出到DISK硬盘中，因为我们需要通过页表来获取实际RAM物理地址，如果页表不在RAM中那我们就没有办法找到页表了（因为我们需要页表进行地址转换，其他设备的数据都是通过页表加载到内存并更新页表）。</p>
<p>那怎么解决这个问题呢？</p>
<p>我们虚拟内存的实现是通过添加一个中间件的思想实现的，那我们可不可以再添加更过的中间件来处理这个问题，答案是肯定的，使用<code>多级页表</code>。</p>
<p>下图是一个例子。</p>
<p><img data-src="virtual-memory/multi-level-page-table1.png"></p>
<p>这个例子中使用了二级页表,一级页表中存了1024个4KB的页的PTE，每个PTE中物理页编号指向的是一个二级页表，这个页表对应存储的才是真正数据对应的物理页。对于每个程序，每个二级页表有1024个PTE，一共有1024个二级页表，那么有1024x1024个PTE，刚好就是1M个PTE，和未使用多级页表中的情况是一样的。</p>
<p>所以有了多级页表机制，我们可以把一级以下的页表换出到DISK硬盘中，因为我们可以通过一级页表来获取它，这也说明了一点我们必须要把一级页表存储在RAM中，就像下面这张图。</p>
<p><img data-src="virtual-memory/multi-level-page-table2.png"></p>
<p>我们来思考一下，使用了多级页表，对于一个32位应用程序我们至少需要多大的内存空间来保存页表呢？<code>4KB+4KB</code>，因为使用了多级页表，一级页表必须存储在RAM中，因为一级页表只告诉我们二级页表的物理地址，所以我们还需要一个二级页表来获取实际的程序数据所在物理地址。一级页表有1024个PTE，每个PTE大约4B，所以一级页表是4KB，二级页表同样如此，所以总共为4KB+4KB，这比4MB好多了！</p>
<p>下面是一个二级页表使用的一个例子。</p>
<p><img data-src="virtual-memory/multi-level-page-table3.png"></p>
<p>CPU使用到了虚拟地址<code>0x00402204</code>，那就需要将其转换为物理地址，转换过程中将虚拟地址分为两个部分：虚拟页号和页内偏移，虚拟页号又分为一级页表编号和二级页表编号。两级页表分别使用虚拟页号的一半（10位），对于虚拟地址0x00402204，一级页表编号N1是<code>0000 0000 01</code>，二级页表编号N2是<code>00 0000 0010</code>，首先使用N1查询RAM中的一级页表得到二级页表的物理页地址（一个页刚好是4KB，二级页表的大小），如果页不在RAM中就需要将它加载到RAM中并更新一级页表，然后使用N2查询二级表获取实际数据的物理页地址，如果实际数据的内存页不在RAM中就需要加载到RAM中并更新二级页表，最终通过物理页地址和虚拟地址的页内偏移得到了最终的物理地址。</p>
<p>小结一下：</p>
<ul>
<li>每个运行的程序需要一个一级页表存储在RAM中，这样可以获取低级的页表以获取实际数据的物理页。</li>
<li>需要一个二级页表存储在RAM中，这样我们可以翻译程序的某些地址，随时切换。</li>
<li>使用两级页表共同完成地址<code>VA-&gt;PA</code>的转换</li>
<li>高10位地址用于索引一级页表的PTE</li>
<li>接下来的10位用于索引二级页表的PTE</li>
<li>我们可以置换页表中的一部分到DISK硬盘中</li>
</ul>
<h3 id="虚拟内存和高速缓存Cache"><a href="#虚拟内存和高速缓存Cache" class="headerlink" title="虚拟内存和高速缓存Cache"></a>虚拟内存和高速缓存Cache</h3><p>这一部分讨论有关TLB转译后备缓冲区和高速缓存Cache的交互问题。</p>
<p>我们通常有两种方式来将TLB和Cache来交互：</p>
<ul>
<li>物理缓存（<code>Physical Cache</code>），Cache使用物理地址（比较慢，访问cache之前必须做一次TLB地址转换，假设TLB转换需要1个周期、物理地址读取Cache需要1个周期）</li>
</ul>
<p><img data-src="virtual-memory/tlb-cache1.png"></p>
<ul>
<li>虚拟缓存（<code>Virtual Cache</code>），Cache使用虚拟地址直接获取缓存数据（很快，1个周期），不必进行地址转换，如果Cache没有命中才会发生地址转换。</li>
</ul>
<p><img data-src="virtual-memory/tlb-cache2.png"></p>
<p>对于虚拟缓存来说，两个程序不能共享虚拟缓存，因为虚拟缓存使用的是虚拟地址，虚拟内存的程序隔离机制无法起作用（因为地址没有转换），这也是虚拟缓存的一个问题。我们也可以简单地解决这个问题，方法就是不仅仅使用虚拟地址，再添加一个标志位用于区分是哪一个应用程序（比如PID）。</p>
<p>有没有两全其美的方法，访问Cache的同时访问TLB，仍然可以使用虚拟内存的隔离机制。</p>
<ul>
<li>还是使用虚拟地址<strong>VA</strong>访问Cache，cache数据记录中有一个物理标志<strong>PTag</strong>，同时通过TLB将虚拟地址<strong>VA</strong>转换为物理地址<strong>PA</strong></li>
<li>通过物理标志<strong>PTag（缓存数据所在的RAM物理地址）</strong>和TLB获取的物理地址<strong>PA</strong>比较是不是命中</li>
</ul>
<p>这只是想法，具体实现还是有些差别，下面一步步说明。</p>
<p><img data-src="virtual-memory/tlb-cache3.png"></p>
<p>这种访问我们称之为<code>虚索引实标签缓存（Virtually Indexed,Physically Tagged）</code>，这是当今处理器中最常用的一级缓存。</p>
<blockquote>
<p>这种缓存利用了页面技术的一个特征，即虚拟地址和物理地址享有相同的页内偏移值（page offset）。(Wikipedia)</p>
</blockquote>
<ul>
<li>Cache通过页内偏移（虚拟和物理是相通的）索引</li>
<li>用物理页面号做标志</li>
</ul>
<p>这样我们既实现了使用虚拟地址访问Cache（快速，不用地址转换），又实现了虚拟内存隔离保护机制（物理地址做标志）。</p>
<blockquote>
<p>这种技术的一个缺点是，在使用直接匹配缓存的前提下，缓存大小不能超过页面大小，否则页面偏移范围就不足以覆盖缓存索引范围。这个弊端可以通过提高组相联路数来改善。(Wikipedia)<strong>（待完善）</strong></p>
</blockquote>
<p>总结一下：</p>
<ul>
<li>TLB地址转换和查询Cache同时进行<ul>
<li>使用虚拟页号进行地址TLB转换</li>
<li>使用虚拟地址偏移量进行cache索引</li>
<li>通过TLB获取了物理页号</li>
<li>通过Cache获取了物理标志（物理页号）</li>
</ul>
</li>
<li>TLB转换得到的物理页号和物理标志<code>PA Tag</code>相等说明缓存命中。</li>
</ul>
<p>这种方式快速的原因是地址转换和cache索引同时进行，安全的原因是Cache只有在物理地址匹配的情况下才会命中。<br><img data-src="virtual-memory/tlb-cache4.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><em><strong>以上便是对虚拟内存的学习和总结，可能还有一些地方会有错误或者知识点漏洞，希望读者可以热情的提出<a target="_blank" rel="noopener" href="https://github.com/ScarboroughCoral/OS-Notes/issues/new">issue</a>。如果还有不理解的地方可以查阅文章末尾我所参考的一些资料，谢谢阅读！</strong></em></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><h4 id="引用作品"><a href="#引用作品" class="headerlink" title="引用作品"></a>引用作品</h4><ul>
<li>David Black-Schaffer.(2014).<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=qcBIvnQt0Bw&index=1&list=PLiwt1iVUib9s2Uo5BeYmwkDFUh70fJPxX">Virtual Memory</a></li>
</ul>
<h4 id="引用文献"><a href="#引用文献" class="headerlink" title="引用文献"></a>引用文献</h4><ul>
<li>Aniruddha-Tapas.(2014).<a target="_blank" rel="noopener" href="https://github.com/Aniruddha-Tapas/Operating-Systems-Notes">Operating Systems Notes</a></li>
<li>wikipedia.(2018).<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CPU%E7%BC%93%E5%AD%98">CPU Cache</a></li>
</ul>
<h4 id="参阅书目"><a href="#参阅书目" class="headerlink" title="参阅书目"></a>参阅书目</h4>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Operating-System/" rel="tag"><i class="fa fa-tag"></i> Operating System</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/shadow-thinking-in-winapi.html" rel="prev" title="浅谈Windows API">
                  <i class="fa fa-chevron-left"></i> 浅谈Windows API
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/osdev-platform.html" rel="next" title="操作系统开发平台">
                  操作系统开发平台 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李明岳</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>


  





</body>
</html>
